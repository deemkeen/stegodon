package activitypub

import (
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"strings"
	"testing"
	"time"

	"github.com/deemkeen/stegodon/domain"
	"github.com/google/uuid"
)

func TestAcceptActivityGeneration(t *testing.T) {
	// Test the structure of Accept activity generated by SendAccept logic
	followID := "https://mastodon.social/follows/123"
	acceptID := "https://stegodon.example/activities/" + uuid.New().String()
	actorURI := "https://stegodon.example/users/alice"
	remoteActorURI := "https://mastodon.social/users/bob"

	accept := map[string]interface{}{
		"@context": "https://www.w3.org/ns/activitystreams",
		"id":       acceptID,
		"type":     "Accept",
		"actor":    actorURI,
		"object": map[string]interface{}{
			"id":     followID,
			"type":   "Follow",
			"actor":  remoteActorURI,
			"object": actorURI,
		},
	}

	// Verify structure can be marshaled
	jsonBytes, err := json.Marshal(accept)
	if err != nil {
		t.Fatalf("Failed to marshal Accept activity: %v", err)
	}

	// Parse back to verify structure
	var parsed map[string]interface{}
	if err := json.Unmarshal(jsonBytes, &parsed); err != nil {
		t.Fatalf("Failed to unmarshal Accept: %v", err)
	}

	if parsed["type"] != "Accept" {
		t.Errorf("Expected type Accept, got %v", parsed["type"])
	}
	if parsed["actor"] != actorURI {
		t.Errorf("Expected actor %s, got %v", actorURI, parsed["actor"])
	}

	// Verify embedded object
	obj := parsed["object"].(map[string]interface{})
	if obj["type"] != "Follow" {
		t.Error("Expected embedded object type Follow")
	}
	if obj["id"] != followID {
		t.Error("Expected embedded object to reference original Follow")
	}
}

func TestCreateActivityGeneration(t *testing.T) {
	// Test Create activity structure for notes
	noteId := uuid.New()
	createdAt := time.Now()
	actorURI := "https://stegodon.example/users/alice"
	noteURI := "https://stegodon.example/notes/" + noteId.String()
	createID := "https://stegodon.example/activities/" + uuid.New().String()

	create := map[string]interface{}{
		"@context":  "https://www.w3.org/ns/activitystreams",
		"id":        createID,
		"type":      "Create",
		"actor":     actorURI,
		"published": createdAt.Format(time.RFC3339),
		"to": []string{
			"https://www.w3.org/ns/activitystreams#Public",
		},
		"cc": []string{
			"https://stegodon.example/users/alice/followers",
		},
		"object": map[string]interface{}{
			"id":           noteURI,
			"type":         "Note",
			"attributedTo": actorURI,
			"content":      "Test note content",
			"published":    createdAt.Format(time.RFC3339),
			"to": []string{
				"https://www.w3.org/ns/activitystreams#Public",
			},
			"cc": []string{
				"https://stegodon.example/users/alice/followers",
			},
		},
	}

	jsonBytes, err := json.Marshal(create)
	if err != nil {
		t.Fatalf("Failed to marshal Create activity: %v", err)
	}

	var parsed map[string]interface{}
	if err := json.Unmarshal(jsonBytes, &parsed); err != nil {
		t.Fatalf("Failed to unmarshal Create: %v", err)
	}

	if parsed["type"] != "Create" {
		t.Error("Expected type Create")
	}

	// Verify addressing
	to := parsed["to"].([]interface{})
	if len(to) != 1 || to[0] != "https://www.w3.org/ns/activitystreams#Public" {
		t.Error("Expected public addressing in to field")
	}

	cc := parsed["cc"].([]interface{})
	if len(cc) != 1 {
		t.Error("Expected followers in cc field")
	}

	// Verify embedded Note
	obj := parsed["object"].(map[string]interface{})
	if obj["type"] != "Note" {
		t.Error("Expected embedded object type Note")
	}
	if obj["content"] != "Test note content" {
		t.Error("Expected note content in object")
	}
}

func TestUpdateActivityGeneration(t *testing.T) {
	// Test Update activity structure
	noteId := uuid.New()
	createdAt := time.Now().Add(-1 * time.Hour)
	editedAt := time.Now()
	actorURI := "https://stegodon.example/users/alice"
	noteURI := "https://stegodon.example/notes/" + noteId.String()
	updateID := "https://stegodon.example/activities/" + uuid.New().String()

	update := map[string]interface{}{
		"@context": "https://www.w3.org/ns/activitystreams",
		"id":       updateID,
		"type":     "Update",
		"actor":    actorURI,
		"to": []string{
			"https://www.w3.org/ns/activitystreams#Public",
		},
		"cc": []string{
			"https://stegodon.example/users/alice/followers",
		},
		"object": map[string]interface{}{
			"id":           noteURI,
			"type":         "Note",
			"attributedTo": actorURI,
			"content":      "Updated content",
			"published":    createdAt.Format(time.RFC3339),
			"updated":      editedAt.Format(time.RFC3339),
			"to": []string{
				"https://www.w3.org/ns/activitystreams#Public",
			},
			"cc": []string{
				"https://stegodon.example/users/alice/followers",
			},
		},
	}

	jsonBytes, err := json.Marshal(update)
	if err != nil {
		t.Fatalf("Failed to marshal Update activity: %v", err)
	}

	var parsed map[string]interface{}
	if err := json.Unmarshal(jsonBytes, &parsed); err != nil {
		t.Fatalf("Failed to unmarshal Update: %v", err)
	}

	if parsed["type"] != "Update" {
		t.Error("Expected type Update")
	}

	obj := parsed["object"].(map[string]interface{})
	if obj["type"] != "Note" {
		t.Error("Expected embedded object type Note")
	}

	// Verify both published and updated timestamps
	if obj["published"] == nil {
		t.Error("Expected published timestamp")
	}
	if obj["updated"] == nil {
		t.Error("Expected updated timestamp")
	}
}

func TestDeleteActivityGeneration(t *testing.T) {
	// Test Delete activity structure
	noteId := uuid.New()
	actorURI := "https://stegodon.example/users/alice"
	noteURI := "https://stegodon.example/notes/" + noteId.String()
	deleteID := "https://stegodon.example/activities/" + uuid.New().String()

	deleteActivity := map[string]interface{}{
		"@context":  "https://www.w3.org/ns/activitystreams",
		"id":        deleteID,
		"type":      "Delete",
		"actor":     actorURI,
		"published": time.Now().Format(time.RFC3339),
		"to": []string{
			"https://www.w3.org/ns/activitystreams#Public",
		},
		"cc": []string{
			"https://stegodon.example/users/alice/followers",
		},
		"object": noteURI,
	}

	jsonBytes, err := json.Marshal(deleteActivity)
	if err != nil {
		t.Fatalf("Failed to marshal Delete activity: %v", err)
	}

	var parsed map[string]interface{}
	if err := json.Unmarshal(jsonBytes, &parsed); err != nil {
		t.Fatalf("Failed to unmarshal Delete: %v", err)
	}

	if parsed["type"] != "Delete" {
		t.Error("Expected type Delete")
	}

	// In Delete, object is just a URI string
	if parsed["object"] != noteURI {
		t.Errorf("Expected object to be URI %s", noteURI)
	}
}

func TestFollowActivityGeneration(t *testing.T) {
	// Test Follow activity structure
	followID := "https://stegodon.example/activities/" + uuid.New().String()
	actorURI := "https://stegodon.example/users/alice"
	remoteActorURI := "https://mastodon.social/users/bob"

	follow := map[string]interface{}{
		"@context": "https://www.w3.org/ns/activitystreams",
		"id":       followID,
		"type":     "Follow",
		"actor":    actorURI,
		"object":   remoteActorURI,
	}

	jsonBytes, err := json.Marshal(follow)
	if err != nil {
		t.Fatalf("Failed to marshal Follow activity: %v", err)
	}

	var parsed map[string]interface{}
	if err := json.Unmarshal(jsonBytes, &parsed); err != nil {
		t.Fatalf("Failed to unmarshal Follow: %v", err)
	}

	if parsed["type"] != "Follow" {
		t.Error("Expected type Follow")
	}
	if parsed["actor"] != actorURI {
		t.Error("Expected local actor URI")
	}
	if parsed["object"] != remoteActorURI {
		t.Error("Expected remote actor URI in object")
	}
}

func TestActivityURIGeneration(t *testing.T) {
	// Test that URIs are properly formatted
	tests := []struct {
		name     string
		domain   string
		username string
		id       string
		uriType  string
		expected string
	}{
		{
			name:     "actor URI",
			domain:   "stegodon.example",
			username: "alice",
			uriType:  "actor",
			expected: "https://stegodon.example/users/alice",
		},
		{
			name:     "activity URI",
			domain:   "stegodon.example",
			id:       uuid.New().String(),
			uriType:  "activity",
			expected: "https://stegodon.example/activities/",
		},
		{
			name:     "note URI",
			domain:   "stegodon.example",
			id:       uuid.New().String(),
			uriType:  "note",
			expected: "https://stegodon.example/notes/",
		},
		{
			name:     "followers URI",
			domain:   "stegodon.example",
			username: "alice",
			uriType:  "followers",
			expected: "https://stegodon.example/users/alice/followers",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var uri string
			switch tt.uriType {
			case "actor":
				uri = "https://" + tt.domain + "/users/" + tt.username
			case "activity":
				uri = "https://" + tt.domain + "/activities/" + tt.id
			case "note":
				uri = "https://" + tt.domain + "/notes/" + tt.id
			case "followers":
				uri = "https://" + tt.domain + "/users/" + tt.username + "/followers"
			}

			if !strings.HasPrefix(uri, "https://") {
				t.Error("URI should use HTTPS")
			}
			if !strings.Contains(uri, tt.domain) {
				t.Error("URI should contain domain")
			}
			if tt.username != "" && !strings.Contains(uri, tt.username) {
				t.Error("URI should contain username")
			}
			if tt.expected != "" && !strings.HasPrefix(uri, tt.expected) {
				t.Errorf("Expected URI to start with %s, got %s", tt.expected, uri)
			}
		})
	}
}

func TestActivityAddressing(t *testing.T) {
	// Test public addressing patterns
	publicURI := "https://www.w3.org/ns/activitystreams#Public"
	followersURI := "https://stegodon.example/users/alice/followers"

	// Test addressing arrays
	to := []string{publicURI}
	cc := []string{followersURI}

	if len(to) != 1 || to[0] != publicURI {
		t.Error("Expected public URI in 'to' field")
	}
	if len(cc) != 1 || cc[0] != followersURI {
		t.Error("Expected followers URI in 'cc' field")
	}

	// Verify JSON serialization
	addressing := map[string]interface{}{
		"to": to,
		"cc": cc,
	}

	jsonBytes, _ := json.Marshal(addressing)
	var parsed map[string]interface{}
	json.Unmarshal(jsonBytes, &parsed)

	parsedTo := parsed["to"].([]interface{})
	if parsedTo[0] != publicURI {
		t.Error("Public URI should be preserved in JSON")
	}
}

func TestMustMarshal(t *testing.T) {
	// Test mustMarshal helper function
	tests := []struct {
		name  string
		input interface{}
		want  string
	}{
		{
			name:  "simple string",
			input: "hello",
			want:  `"hello"`,
		},
		{
			name:  "map",
			input: map[string]string{"type": "Follow"},
			want:  `{"type":"Follow"}`,
		},
		{
			name:  "array",
			input: []string{"a", "b"},
			want:  `["a","b"]`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := mustMarshal(tt.input)
			if result != tt.want {
				t.Errorf("Expected %s, got %s", tt.want, result)
			}
		})
	}
}

func TestMustMarshalPanic(t *testing.T) {
	// Test that mustMarshal panics on error (e.g., channels cannot be marshaled)
	defer func() {
		if r := recover(); r == nil {
			t.Error("Expected mustMarshal to panic on unmarshallable type")
		}
	}()

	ch := make(chan int)
	mustMarshal(ch) // Should panic
}

func TestActivityTimestamps(t *testing.T) {
	// Test RFC3339 timestamp formatting
	now := time.Now()
	formatted := now.Format(time.RFC3339)

	// Verify format is correct
	if !strings.Contains(formatted, "T") {
		t.Error("RFC3339 should contain T separator")
	}
	if !strings.Contains(formatted, ":") {
		t.Error("RFC3339 should contain time separators")
	}

	// Parse back to verify
	parsed, err := time.Parse(time.RFC3339, formatted)
	if err != nil {
		t.Fatalf("Failed to parse RFC3339 timestamp: %v", err)
	}

	// Times should be equal within a second
	if parsed.Sub(now) > time.Second || now.Sub(parsed) > time.Second {
		t.Error("Timestamp parsing should preserve time accurately")
	}
}

func TestDeliveryQueueItemCreation(t *testing.T) {
	// Test creating delivery queue items
	inboxURI := "https://mastodon.social/inbox"
	activity := map[string]string{"type": "Create"}
	activityJSON := mustMarshal(activity)

	queueItem := &domain.DeliveryQueueItem{
		Id:           uuid.New(),
		InboxURI:     inboxURI,
		ActivityJSON: activityJSON,
		Attempts:     0,
		NextRetryAt:  time.Now(),
		CreatedAt:    time.Now(),
	}

	if queueItem.InboxURI != inboxURI {
		t.Error("InboxURI should be set correctly")
	}
	if queueItem.Attempts != 0 {
		t.Error("New queue items should start with 0 attempts")
	}
	if queueItem.ActivityJSON != activityJSON {
		t.Error("Activity JSON should be stored")
	}

	// Verify activity can be unmarshaled
	var parsedActivity map[string]string
	if err := json.Unmarshal([]byte(queueItem.ActivityJSON), &parsedActivity); err != nil {
		t.Error("Stored activity JSON should be valid")
	}
	if parsedActivity["type"] != "Create" {
		t.Error("Activity should be preserved in queue")
	}
}

func TestHTTPHeaders(t *testing.T) {
	// Test that we set proper headers for ActivityPub
	contentType := "application/activity+json"
	accept := "application/activity+json"
	userAgent := "stegodon/1.0 ActivityPub"

	if contentType != "application/activity+json" {
		t.Error("Content-Type should be application/activity+json")
	}
	if accept != "application/activity+json" {
		t.Error("Accept should be application/activity+json")
	}
	if !strings.Contains(userAgent, "stegodon") {
		t.Error("User-Agent should identify as stegodon")
	}
}

func TestDigestCalculation(t *testing.T) {
	// Test digest header calculation for HTTP signatures
	activityJSON := []byte(`{"type":"Follow"}`)

	// This is what SendActivity does
	hash := sha256.Sum256(activityJSON)
	digest := "SHA-256=" + base64.StdEncoding.EncodeToString(hash[:])

	if !strings.HasPrefix(digest, "SHA-256=") {
		t.Error("Digest should have SHA-256= prefix")
	}
	if len(digest) < 50 {
		t.Error("Digest should contain base64 encoded hash")
	}

	// Verify the same input produces same digest
	hash2 := sha256.Sum256(activityJSON)
	digest2 := "SHA-256=" + base64.StdEncoding.EncodeToString(hash2[:])
	if digest != digest2 {
		t.Error("Same input should produce same digest")
	}
}

func TestKeyIDFormat(t *testing.T) {
	// Test key ID formatting for HTTP signatures
	domain := "stegodon.example"
	username := "alice"
	keyID := "https://" + domain + "/users/" + username + "#main-key"

	if !strings.HasPrefix(keyID, "https://") {
		t.Error("Key ID should use HTTPS")
	}
	if !strings.Contains(keyID, username) {
		t.Error("Key ID should contain username")
	}
	if !strings.HasSuffix(keyID, "#main-key") {
		t.Error("Key ID should end with #main-key")
	}

	expectedFormat := "https://stegodon.example/users/alice#main-key"
	if keyID != expectedFormat {
		t.Errorf("Expected key ID %s, got %s", expectedFormat, keyID)
	}
}

func TestPublicURIConstant(t *testing.T) {
	// Test the public addressing constant
	publicURI := "https://www.w3.org/ns/activitystreams#Public"

	if !strings.HasPrefix(publicURI, "https://") {
		t.Error("Public URI should use HTTPS")
	}
	if !strings.Contains(publicURI, "activitystreams") {
		t.Error("Public URI should reference ActivityStreams")
	}
	if !strings.HasSuffix(publicURI, "#Public") {
		t.Error("Public URI should end with #Public")
	}
}

func TestContextURI(t *testing.T) {
	// Test ActivityStreams context URI
	contextURI := "https://www.w3.org/ns/activitystreams"

	if !strings.HasPrefix(contextURI, "https://") {
		t.Error("Context URI should use HTTPS")
	}
	if !strings.Contains(contextURI, "w3.org") {
		t.Error("Context should be from W3C")
	}
}
